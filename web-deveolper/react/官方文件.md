# React的官方文件筆記

## 表單

1. 會讀這篇是因為第一次用form的時候，不知道有e.preventDefault可以用，那時候發現用form網頁會被refrash，行不通。
2. 基本上form的結構是在form的地方有一個onSubmit來處理submit，然後按鈕是一個input，他的type是submit。
3. 這種用來控制表單的component叫作[Controlled Component](https://zh-hant.reactjs.org/docs/forms.html#controlled-components)
4. 利用一個handler就可以處理多個input，主要是基於每一次event發生，只會變動一個input，所以可以去把不同的name和value的state設定進state。

## Context

1. [連結](https://reactjs.org/docs/context.html#reactcreatecontext)
2. 步驟：
   1. 設定context：
      1. 會有一些constants要給context和setState來用，比較方便。
      2. 用createContext建立一個context，給一個parameter給createContext當成這個context的value，這個parameter通常會是一個object，像是props的用法，可以放value或是function。
      3. 要用context的class component有一個contextType的屬性可以設定成這個context。
      4. 這個component裡面的this.context可以取得context的value
      5. 用這個value來render出要的東西，這就是comsumer
   2. 使用context：
      1. 這個component可以被拿來包住別人使用。
      2. 使用的方式是把provider包住祖先，把value給provider的props
      3. 用comsumer包住要用value的子孫，就可以把value或是function當成props做成需要component來用。
   3. 效能：
      1. 注意provider的value是一個object可能會一直造成所有comsumers不斷的re-render，因為provider所在地render完彈value那個props裡的object會被重新作出來。
      2. 解決方式是把value放在state裡。

## SyntheticEvent

1. [連結](https://zh-hant.reactjs.org/docs/events.html)
2. 事件名稱：
   1. 指的就是dom element可以監聽的屬性，像是onClick之類的。
   2. 常用的：onFocus, onBlur, onKeyPress, onCopy, onChange, onLoad, onClick, onDoubleClick, onDrag, onDrop, onMouseEnter, onTouchEnd, onScroll, onPlay等
3. 屬性：
   1. 指的是觸發後event的屬性：
   2. 常用的：key, keyCode, currentTarget(target的祖先), target, relatedTarget(target的兄弟), 

## Portal (傳送門)

1. [連結](https://zh-hant.reactjs.org/docs/portals.html)
2. 使用時機是同時符合以下兩種情況：(dialog、hovercard 與 tooltip)
   1. 想跳脫原來的root DOM tree。
   2. 弄出來的component仍可以被parent component控制，例如event bubbling可以觸發爸爸，props也可以傳給child。
3. `ReactDOM.createPortal(<ModalChild />, document.getElementById('modal-root'))`和`ReactDOM.render()`是一樣的用法。
4. 但是為了讓`<Modal />`能包住不同的`<Child />`得以重用，就要用到比較進階的寫法。
   1. html裡一樣寫一個modal-root的element，我們用JS來操作它：`const modalRoot = document.getElementById('modal-root');`。
   2. 在`<Modal />`裡的`constructor`裡要先建立一個element：`this.el = document.createElement('div');`
   3. 在`componentDidMount`裡把`modalRoot`的小孩放進這個div：`modalRoot.appendChild(this.el);`
   4. 在`componentWillUnmount`裡把`modalRoot`的小孩移除。
   5. 這時候就可以把傳進來的小孩，用modalRoot的小孩給render出來：

      ```jsx
      render() {
         return ReactDOM.createPortal(
            this.props.children,
            this.el
         );
      }
      ```

   6. 要搞清楚第一個參數是component，第二個參數是element。
   7. 和一般的`ReactDOM.render()`看起來寫法不一樣，只是為了讓`<Modal />`可以包住`<ModalChild />`重用，要讓第一個參數是傳進來的小孩component，第二個參數是`modalRoot`的小孩。
5. 使用方式：

      ```jsx
      render() {
         return (
            <Modal>
               <ModalChild />
            </Modal>
         );
      }
      ```

6. 官網沒寫的：
   1. 事實上使用Portal並不會讓你的Modal的view疊上你的DOM tree，要讓你的Modal的view疊上你的DOM tree主要還是要靠CSS對作標和大小給值，還要position下fixed的value，才能達到一般Modal的外觀。
   2. 那為什麼還需要用Portal的作法呢？
      1. 我猜是因為是要做一個可以重複使用的Portal component。
      2. 首先如果可以重複使用，視覺上需要跳脫原來的parent，可能這樣的關係，跳脫root的安排可能會比較合理吧？
      3. 但我覺得最可能的原因是，整個DOM tree很複雜，而且是動態的，搞不好祖先裡突然裡面render出哪個特殊CSS屬性，讓你的子孫Modal css跳出設定突然失去了，那會很難預期，所以直接跳出原來的root DOM tree比較保險。
